---
title: "Raster Polygonizer Workflow"
output:
  rmarkdown::html_vignette:
    css: vignette-style.css
vignette: >
  %\VignetteIndexEntry{Raster Polygonizer Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,
  message    = FALSE,
  warning    = FALSE,
  fig.align  = "center",
  fig.width  = 7,
  fig.height = 4.5
)
library(rasterpolygonizer)
if (!requireNamespace("sf",    quietly = TRUE)) stop("Install 'sf' to run this vignette")
if (!requireNamespace("terra", quietly = TRUE)) stop("Install 'terra' to run this vignette")
```

# From LiDAR Scan to Building Footprint

*A complete workflow for extracting, filtering, and characterizing rooftop polygons from aerial elevation data*

---

## Why This Package?

Heavy snow accumulation on rooftops is a serious safety concern in cold climates — when loads grow too large, roofs can fail catastrophically. Understanding and predicting this risk requires detailed information about building geometry across entire cities, but traditional manual surveys are slow, expensive, and limited in scale.

Airborne LiDAR (Light Detection and Ranging) offers a powerful alternative. By bouncing laser pulses off surfaces from an aircraft and recording the return time, LiDAR produces dense, precise three-dimensional maps of the built environment. Comparing scans taken before and after a snowfall event makes it possible to measure rooftop snow accumulation automatically — at city scale, for thousands of buildings at once.

`rasterpolygonizer` packages the full processing chain needed to go from a raw LiDAR-derived elevation raster to a clean, attributed set of building footprints, ready for snow load analysis, engineering assessment, or any other rooftop-scale application.

---

## Workflow Overview

The six functions in this package form a linear pipeline. Each step produces output consumed by the next:

| Step | Function | Purpose |
|:----:|----------|---------|
| 1 | `fill_ground_raster()` | Fill voids using clustering-based ground estimation |
| 2 | `extract_building_edges_to_polygons()` | Detect edges via Sobel gradients and close them morphologically |
| 3 | `clean_building_polygons()` | Polygonize enclosed interiors, then shrink, simplify, and filter by area |
| 4 | `filter_by_ground_truth()` | Retain candidates with sufficient containment within reference footprints |
| 5 | `remove_invalid_polys()` | Remove ground-contaminated and nested polygons |
| 6a | `estimate_building_height()` | Estimate height relative to surrounding ground elevation |
| 6b | `roof_slope_RANSAC()` | Fit robust planes and derive slope and aspect per roof |

Steps 6a and 6b are independent characterization steps — run either or both depending on your analysis goals.

---

## Load Example Data

```{r load-data}
library(ggplot2)

load_extdata <- function(filename, pkg = "rasterpolygonizer") {
  path <- system.file("extdata", filename, package = pkg)
  if (path == "") stop(sprintf("File '%s' not found in inst/extdata", filename))
  path
}

r <- terra::rast(load_extdata("sample_raster.tif"))
b <- sf::st_read(load_extdata("sample_buildings.gpkg"), quiet = TRUE)
```

The sample dataset covers a small area of Fairbanks, Alaska. `r` is a LiDAR-derived digital surface model (DSM) — a raster where each cell records the elevation of the highest surface at that location, whether bare earth, a rooftop, or a tree. `b` contains digitized building footprints provided by the Fairbanks North Star Borough.

---

#We define a shared ggplot theme using a warm earth-tone document background, and a blue-to-gold raster fill palette. Blue and gold sit across from each other on the color wheel — the cool-to-warm contrast gives elevation data strong visual pop against the neutral document background while remaining readable in print.

```{r theme, include=FALSE}
theme_rp <- function() {
  theme_minimal(base_size = 11) +
    theme(
      plot.background   = element_rect(fill = "#f5f0e8", color = NA),
      panel.background  = element_rect(fill = "#f5f0e8", color = NA),
      panel.grid        = element_line(color = "#ddd5c0", linewidth = 0.3),
      plot.title        = element_text(face = "bold", color = "#3b2f1e", size = 12),
      plot.subtitle     = element_text(color = "#6b5740", size = 10),
      legend.background = element_rect(fill = "#f5f0e8", color = NA),
      legend.title      = element_text(color = "#3b2f1e", size = 9),
      legend.text       = element_text(color = "#3b2f1e", size = 8),
      axis.text         = element_text(color = "#6b5740", size = 8)
    )
}

# Blue-to-gold: complementary to the warm document background
scale_fill_rp <- function(...) {
  scale_fill_gradientn(
    colors = c("#1a3a5c", "#1d6fa4", "#4ba3c7", "#a8d5e2"),
    ...
  )
}
```


## Step 1 — Fill the Ground Raster

**`fill_ground_raster(raster, w = 15)`**

LiDAR point clouds frequently contain data voids where the sensor received no usable return, typically due to occlusion between the collection device and the point of measurement. Left unfilled, these holes disrupt the gradient computation in Step 2.

`fill_ground_raster()` addresses this with a focal neighborhood approach designed specifically for elevation data. For each NA cell, it examines all valid neighbors within a `w × w` window and uses k-means clustering (up to 3 clusters) to separate them by elevation. It then returns the median of the *lowest* cluster — the best available estimate of ground level at that location. This means the fill preferentially recovers ground-level values rather than being pulled upward by nearby rooftops or vegetation, which is exactly what downstream processing needs.

**`w`** (default `15`): The focal window size in pixels. Larger windows can fill bigger voids but may pull values from more distant and less representative neighbors. Typically this window size will work well unless the buildings of interest are very large.

```{r fill, out.width="70%"}
r_df_raw <- as.data.frame(r, xy = TRUE, na.rm = TRUE)
names(r_df_raw)[3] <- "value"

ggplot(r_df_raw) +
  geom_raster(aes(x = x, y = y, fill = value)) +
  coord_equal() +
  scale_fill_rp(name = "Elev. (m)") +
  theme_rp() +
  labs(
    title    = "Raw Input Raster",
    subtitle = "LiDAR digital surface model — voids appear where returns were absent or filtered"
  )

r_filled <- fill_ground_raster(r)

r_df_filled <- as.data.frame(r_filled, xy = TRUE, na.rm = TRUE)
names(r_df_filled)[3] <- "value"

ggplot(r_df_filled) +
  geom_raster(aes(x = x, y = y, fill = value)) +
  coord_equal() +
  scale_fill_rp(name = "Elev. (m)") +
  theme_rp() +
  labs(
    title    = "Filled Ground Raster",
    subtitle = "Voids filled using clustering-based ground estimation"
  )
```

---

## Step 2 — Extract Building Edge Polygons

**`extract_building_edges_to_polygons(raster, smooth_w, thr_prob, morph_w)`**

Buildings appear in a DSM as abrupt vertical discontinuities — sharp jumps in elevation from ground to rooftop. This function detects those discontinuities through a four-stage image processing pipeline:

1. **Smoothing** — a mean focal filter reduces sensor noise before gradient computation
2. **Sobel gradient** — horizontal (Gx) and vertical (Gy) Sobel kernels are applied to the smoothed raster, and their combined magnitude (`sqrt(Gx² + Gy²)`) captures edge strength in all directions
3. **Thresholding** — pixels whose gradient magnitude exceeds the `thr_prob` quantile of all gradient values are classified as edges
4. **Morphological closing** — a expand-then-erode operation bridges small gaps in the detected edge lines, producing closed loops that surround building interiors

**`thr_prob`** (default `0.70`): The quantile threshold applied to gradient magnitude. At `0.70`, the top 30% of gradient values are classified as edges. *Raising this value makes the detector more selective* — only the strongest gradients (sharpest elevation transitions) pass through, which helps in dense urban scenes with many small buildings where vegetation and clutter produce weaker false edges. Lowering it recovers subtler edges but increases noise.

```{r edges}
edges <- extract_building_edges_to_polygons(r_filled, thr_prob = 0.8)
```

---

## Step 3 — Clean Building Polygons

**`clean_building_polygons(closed_edges, shrink_dist, simplify_tol, min_area, max_area)`**

The closed edge loops from Step 2 define the *perimeters* of buildings, but what we actually need are filled polygon footprints. The key insight in this function is that the edge loops enclose interior regions — so the function first *inverts* the edge raster and polygonizes the enclosed FALSE (interior) regions. Those interiors are the building footprints.

After polygonization, three cleaning operations are applied in sequence:

**`shrink_dist`** (default `-0.5`, map units): A negative buffer shrinks each polygon inward. This is necessary because the edge band detected in Step 2 sits slightly outside the true rooftop boundary — the shrink compensates for that outward bias. Use a more negative value for coarser-resolution rasters where the edge band is wider.

**`simplify_tol`** (default `0.5`, map units): Douglas-Peucker simplification removes redundant vertices and smooths jagged outlines without distorting the overall footprint shape. Larger values produce cleaner but blockier polygons.

**`min_area` / `max_area`**: After exploding all multi-part geometries into individual polygons, those outside this size range are dropped. `min_area` removes noise patches and the small gaps between edge pixels; `max_area` removes the large background region (the inverted raster always produces one polygon covering everything *outside* the buildings, which is discarded here).

The function also computes and attaches `area`, `perimeter`, `perim_area_ratio`, and `vertices` columns to the output for downstream use.

```{r clean, out.width="70%"}
buildings_sf <- clean_building_polygons(
  closed_edges = edges$closed_edges,
  shrink_dist  = -1.5,
  simplify_tol = 2.5,
  min_area     = 19.99,
  max_area     = 3000
)

r_df <- as.data.frame(r_filled, xy = TRUE, na.rm = TRUE)
names(r_df)[3] <- "value"

ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = buildings_sf, fill = NA, color = "#c47c0f", linewidth = 1) +
  coord_sf() +
  scale_fill_rp(name = "Elev. (m)") +
  theme_rp() +
  labs(
    title    = "Candidate Building Polygons",
    subtitle = "Interior regions enclosed by edge loops, shrunk and simplified"
  )
```

---

## Step 4 — Filter by Ground Truth

**`filter_by_ground_truth(candidates, truth, threshold = 0.75)`**

Not every candidate polygon corresponds to a real building — some will be vegetation clumps, elevated infrastructure, or detection artifacts. When a reference layer of known building footprints is available (e.g., from municipal GIS records or manual digitizing), this function uses spatial overlap to filter out false detections.

For each candidate polygon, the function computes a **containment ratio**: the area of intersection with any overlapping reference polygon divided by the total area of the candidate. If this ratio meets or exceeds `threshold`, the candidate is kept. A ratio of `0.75` means that at least 75% of the detected polygon's area must fall inside a reference footprint.

Note that this is a one-sided measure — it evaluates how well the *candidate* is contained within the reference, not the reverse. This means a smaller detected polygon that sits neatly inside a large reference footprint will pass, while a candidate that extends significantly beyond the reference boundary will be rejected.

> **No reference layer available?** Skip this step and proceed directly to Step 5. The function is optional in the pipeline.

**`threshold`** (default `0.75`): Lower values recover more partial matches at the cost of accepting more false detections; higher values demand tighter spatial agreement with the reference.

```{r filter, out.width="70%"}
# Assign a CRS to align all layers (UTM Zone 6N for Fairbanks, AK)
terra::crs(r)        <- "EPSG:32606"
r_crs                <- terra::crs(r)
terra::crs(r_filled) <- r_crs
buildings_sf         <- sf::st_set_crs(buildings_sf, r_crs)
b                    <- sf::st_set_crs(b, r_crs)

filtered <- filter_by_ground_truth(
  buildings_sf,
  b,
  threshold = 0.75
)

ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = filtered, fill = NA, color = "#c47c0f", linewidth = 1) +
  coord_sf() +
  scale_fill_rp(name = "Elev. (m)") +
  theme_rp() +
  labs(
    title    = "After Ground Truth Filtering",
    subtitle = "Candidates retained where ≥50% of their area overlaps a reference footprint"
  )
```

---

## Step 5 — Remove Invalid Polygons

**`remove_invalid_polys(polys, raster, buffer_dist, ground_tol, remove_nested)`**

This function performs two distinct cleanup passes in a deliberate order.

**Pass 1 — Ground contamination check:** For each polygon, the function extracts the minimum elevation value inside the polygon and the minimum elevation value in a surrounding buffer ring of width `buffer_dist`. If the absolute difference between these two minima is less than `ground_tol`, the polygon is flagged as ground-contaminated and removed. The logic is straightforward: a polygon sitting on an actual rooftop should have notably higher minimum elevations than the ground immediately surrounding it. If the inside and outside minima are nearly the same, the polygon is likely sitting on flat ground rather than a raised surface.

**Pass 2 — Nested polygon removal:** After ground filtering, any polygon that is fully spatially contained within another polygon is removed. This handles cases where the edge detection and polygonization steps produce concentric outlines around the same building. Ground-contaminated polygons are removed *before* this step intentionally — otherwise, a large invalid polygon could cause valid smaller polygons nested within it to be incorrectly discarded.

**`ground_tol`** (default `3`, map units): The minimum elevation difference required between inside and outside minima to consider a polygon a valid raised structure. Increase this in flat terrain where small elevation differences are common noise; decrease it where rooftop-to-ground relief is reliably large.

**`buffer_dist`** (default `5`, map units): Width of the exterior ring used for the ground comparison. Should be wide enough to capture true ground-level values beyond the building footprint, but not so wide that it picks up adjacent buildings.

```{r remove-invalid, out.width="70%"}
valid_polys <- remove_invalid_polys(filtered, r_filled, ground_tol = 1)

ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = valid_polys, fill = NA, color = "#c47c0f", linewidth = 1) +
  coord_sf() +
  scale_fill_rp(name = "Elev. (m)") +
  theme_rp() +
  labs(
    title    = "Validated Building Polygons",
    subtitle = "Ground-contaminated and nested polygons removed"
  )
```

---

## Step 6a — Estimate Building Height

**`estimate_building_height(polys, raster, buffer_dist, prob, clamp)`**

Rather than simply averaging elevation values inside a polygon (which would give absolute rooftop elevation, not building height), this function estimates height *relative to the surrounding ground*. For each polygon it computes a low percentile of raster values inside the polygon (`inside_q`) and the same percentile in a surrounding buffer ring (`outside_q`). Height is then `inside_q - outside_q`.

Using a low percentile (default `prob = 0.02`, the 2nd percentile) rather than the minimum makes the estimate robust to rooftop features like dips or holes. The same percentile is used for both inside and outside values for consistency. If `clamp = TRUE`, negative heights (which can arise from noisy data or polygon edge effects) are set to zero. Using as low a value as possible inside our interior polygon will help to combat bias towards the peak of gabled roofs.

The function returns the input polygon layer with three new columns: `inside_q`, `outside_q`, and `height`.

**`buffer_dist`** (default `5`, map units): Width of the exterior ring used to sample surrounding ground elevation. Should extend far enough to clear the building footprint and capture true ground values.

**`prob`** (default `0.02`): Quantile used for both inside and outside elevation estimates. Lower values are more robust to high-elevation outliers but may be sensitive to data voids if coverage is thin.

```{r height, out.width="70%"}
df <- estimate_building_height(valid_polys, r_filled)

knitr::kable(
  head(df[, c("building_id", "inside_q", "outside_q", "height")], 10),
  digits  = 2,
  caption = "Estimated building height for the first 10 polygons. Height is the difference between the 2nd-percentile rooftop elevation and the 2nd-percentile ground elevation in the surrounding buffer ring."
)
```

---

## Step 6b — Roof Slope and Aspect via RANSAC

**`roof_slope_RANSAC(raster, buildings, n_iter, thresh, min_inliers)`**

Roof slope and orientation (aspect) are key determinants of snow retention — a steep south-facing roof sheds snow quickly, while a shallow north-facing roof may accumulate loads several times greater. This function fits a plane to the raster elevation values within each polygon using RANSAC (Random Sample Consensus), a robust estimation method that explicitly tolerates outlier pixels caused by dormers, vents, parapets, and sensor noise.

Each RANSAC iteration randomly draws 3 pixels from the building's raster footprint, fits a plane through them via linear regression (`z ~ x + y`), and counts how many of the *remaining* pixels have residuals below `thresh` (inliers). After `n_iter` iterations, the plane that maximized inlier count is selected and used to compute final slope and aspect:

- **Slope** = `atan(sqrt(a² + b²)) × 180/π`, where `a` and `b` are the x and y plane coefficients
- **Aspect** = `(atan2(-a, -b) × 180/π) %% 360`, giving compass bearing of the downslope direction

A **stability metric** (`slope_range`) is also returned: the 97.5th minus 2.5th percentile of slope estimates across the top 5% of candidate fits, ranked by inlier count. A low value means those top candidates agreed closely — the roof surface is planar and the fit is reliable. A high value suggests the roof geometry is complex or the data is noisy.

**`thresh`** (default `0.1`, elevation units): The residual distance within which a pixel is counted as an inlier. Tighten this for high-density LiDAR where rooftop surfaces are reliably smooth. Loosen it for coarser data where pixel-to-plane scatter is inherently larger. *For scenes with many small buildings, individual polygons contain fewer pixels, so each pixel carries more weight — a tighter `thresh` here helps ensure the fitted plane is genuinely representative of the roof surface rather than a statistical accident.*

**`min_inliers`** (default `10`): Minimum pixels required to accept any candidate plane. For small buildings with few raster cells, or lower resolution rasters, lower this to avoid discarding valid fits. For large buildings, raising it ensures the plane is well-supported across the full footprint. Mostly this parameter is treated as a fail-safe, and is not meant to be tuned.

**`n_iter`** (default `500`): Number of random 3-point samples evaluated. More iterations improve the chance of finding the globally best plane. Raise this towards the ceiling of what computational power will allow for best-fit estimates.

```{r ransac, out.width="70%"}
buildings_sv <- terra::vect(valid_polys)

if (!"building_id" %in% names(buildings_sv)) {
  buildings_sv$building_id <- seq_len(nrow(buildings_sv))
}

ransac_result <- roof_slope_RANSAC(
  raster      = r_filled,
  buildings   = buildings_sv,
  n_iter      = 500L,
  thresh      = 0.1,
  min_inliers = 10L,
  quiet       = TRUE
)

knitr::kable(
  head(ransac_result$summary_table, 10),
  digits  = 2,
  caption = "Roof slope and aspect estimates. slope_range is the spread of slope values across the top 5% of RANSAC candidate fits — lower values indicate a more stable, reliable plane fit."
)
```

---

## What's Next?

With per-building height, slope, and aspect values in hand, the natural next steps are:

- **Snow load estimation** — difference two DSMs (pre- and post-snowfall) within each validated polygon to derive snow depth, then combine with slope to estimate structural load
- **Spatial aggregation** — summarize risk metrics by neighborhood, building type, or construction era
- **Validation** — compare derived slope values against as-built drawings or field measurements to quantify method accuracy

All outputs are standard R objects — `sf` data frames and `terra` rasters — and can be written to disk with `sf::st_write()` and `terra::writeRaster()` respectively.
